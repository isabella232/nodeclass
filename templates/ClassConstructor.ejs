<% /* constructor definition begins here */ %>
var Constructor = function() {
    var tmp,
        implChildAbstracts,
        implAbstracts,
        constructorIsRunning,
        exposeProtected,
        exposeNothing,
        Properties,
        Instance,
        key;

    <% /* reads the flag-object. these flags are used to modify the constructor's behaviour. */ %>
    if(Constructor.$) {
        tmp = Constructor.$;
        Instance = tmp.Instance; <% /* provides the reference to the first child class that can be obtained via this.Instance */ %>
        implChildAbstracts = tmp.implChildAbstracts; <% /* an array that contains references to all abstract functions that are implemented in a child class */ %>
        constructorIsRunning = tmp.constructorIsRunning; <% /* indicates that this constructor is not finished yet. if this flag is true, an recursion error is thrown */ %>
        exposeProtected = tmp.exposeProtected; <% /* if true, the constructor function exposes all protected class members */ %>
        exposeNothing = tmp.exposeNothing; <% /* if true, the constructor does nothing */ %>
    }

    if(constructorIsRunning) { <% /* if the constructor is currently running, it looks like it's trying to call itself. therefore a recursion error is thrown. */ %>
        throw new Error("Class error in " + __filename + ": Constructor recursion detected.");
        return;
    } else {
        Constructor.$ = {
            "constructorIsRunning": true
        };
    }

    <%= abstractInstanceError %> <% /* if the class is abstract and the constructor is called by a non-child an error must be thrown */ %>

    if(!exposeNothing) {
        if(!implChildAbstracts) {
            implChildAbstracts = {};
        }

        if (Instance === undefined) {
            Instance = this;
        }
        Properties = {};  <% /* creates the Properties-object, where all the class's properties are stored */ %>
        <%= properties %> <% /* gets replaced by various assignments for all properties: private, protected, public */ %>
        Properties.Instance = Instance;

        implAbstracts = implChildAbstracts;

        <% /* gets replaced by an object carrying all former abstract methods that are implemented by this class or a child class */ %>
        <% /* the next section is used to assign all abstract methods that are implemented by a child class to the current Properties-object. */ %>
        <% /* this is necessary so you can call this.abstractMethod in an abstract class. */ %>
        <%= implAbstracts %>
        for(key in implChildAbstracts) {
            if(implChildAbstracts.hasOwnProperty(key)) {
                Properties[key] = implChildAbstracts[key];
            }
        }

        <%= superConstructor %> <% /* gets replaced by the SuperConstructor-function, but only in case of the class has a super class. */ %>
        <%= initCall %> <% /* the init function is called now, if it is available */ %>
        <%= superConstructorCall %> <% /* now the super constructor is called in case of it hasnt been called by the init function of this class. */ %>

        <%= wrapper %> <% /* gets replaced by various assignments for all public properties */ %>
        if(exposeProtected) {
            <%= exposeWrapper %> <% /* gets replaced by various assignments for all protected properties */ %>
        }
    }

    delete Constructor.$; <% /* deletes the flag-object */ %>
};
<% /* constructor definition ends here */ %>

Constructor.$construct = function(args) { <% /* this special function is used to call the constructor with an argument-array since you cant use the .apply()-method with the new operator. */ %>
    var Instance = function Instance() {
        return Constructor.apply(this,args);
    };
    Instance.prototype = Constructor.prototype;
    return new Instance();
};